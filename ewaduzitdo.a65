; 		WADUZITDO
;	6800 VERSION BY LARRY KHERIATY
;
;	6502 'EXTENDED' VERSION BY DIMITRI THEULINGS
;
; KIM-1 SUBROUTINES USED
GETCH	.EQU	$1E5A		; INPUT FROM KEYBOARD TO A
OUTCH	.EQU	$1EA0		; OUTPUT FROM A TO TERMINAL
CRLF	.EQU	$1E2F		; OUTPUT CR/LF TO TERMINAL

;
; ZERO PAGE DATA
;
LOCP	.EQU	$60		; POINTER TO USER PROGRAM LOCATION
LSTP	.EQU	$62		; POINTER TO LAST A:
CHR	.EQU	$64		; LAST INPUT CHAR PLACEHOLDER
FLG	.EQU	$65		; MATCH FLAG PLACEHOLDER

BLE	.MACRO	disp		; BRANCH LESS THAN OR EQUAL
	BCC	\1		; BRANCH LESS THAN
	BEQ	\1		; BRANCH EQUAL
	.ENDM

	.ORG	$200
SUB	.EQU	*		; USER SUBR START (CAN BE MODIFIED)
; ENTER SYSTEM AT LOCATION 200 WITH STACK POINTER PRESET
; TO SCRATCH PAD RAM ENOUGH FOR A FEW LEVELS OF JSR CALLS
;
START	LDY	#0		; RESET PGM INDEX PTR
	LDA	#>LOC		; INITIALISE USER PGM MSB
	STA	LOCP+1
	LDA	#<LOC		; INIT USER PGM LSB
	STA	LOCP
EGET	JSR	JIN		; ACCEPT SOURCE CHAR
	CMP	#'\\'		; \  ?
	BEQ	START		; YES, BACK UP TO PROGRAM START
;
	CMP	#'$'		; $  ?
	BEQ	EXEC		; YES, GO EXECUTE THE PROGRAM
;
	CMP	#'\b'		; BACKSPACE  ?
	BNE	DIS		; NO
	DEC	LOCP		; DECREMENT PROG POINTER
	BPL	EGET		; DIDN'T CROSS PAGE BOUNDARY
	DEC	LOCP+1		; DECREMENT POINTER MSB
	BNE	EGET		; LOOP BACK
;
; PROCESS DISPLAY OF NEXT LINE
DIS	CMP	#'/'		; /  ?
	BNE	PAD		; NO
	JSR	PRT		; GO PRINT TO CR
EPLF	JSR	LFOUT		; PRINT LINEFEED AND NULLS
	JMP	EGET		; LOOP
;
; DO LINE REPLACEMENT - PAD TO END OF STMT WITH NULLS
PAD	CMP	#'%'		; %  ?
	BNE	CHAR		; NO
	LDA	#'\r'		; CR
	JSR	JOUT		; PRINT IT
	LDX	#$40		; COUNT OF 64
PADL	LDA	(LOCP),Y	; CR
	CMP	#$D		; AT CR YET?
	BEQ	CHAR		; YES QUIT PADDING
	LDA	#0		; NULL CHARACTER
	STA	(LOCP),Y	; PAD WITH NULL
	JSR	INCP		; INCR LOC PTR
	DEX			; DECREMENT SAFETY COUNTER
	BNE	PADL		; LOOP TILL CR OR 64 NULLS
;
; STORE ENTERED SOURCE CHAR IN PROGRAM
CHAR	STA	(LOCP),Y	; CHAR TO SOURCE LOC
	JSR	INCP		; MOVE LOC PTR UP ONE
	CMP	#'\r'		; IS IT A CR ?
	BEQ	EPLF		; YES, ECHO A LINEFEED
	JMP	EGET		; NO, GET ANOTHER CHAR
;
; NEXT FEW LINES MUST BE ALTERED IF NOT USING KIM-1
JIN	JSR	GETCH		; CALL CHARACTER INPUT ROUTINE
	BNE	:+
JOUT	JSR	OUTCH		; CALL CHARACTER OUTPUT ROUTINE
	BNE	:+		; RESTORE Y REGISTER
LFOUT	JSR	CRLF		; CALL CR/LF OUTPUT ROUTINE
:	LDY	#0		; RESTORE Y REGISTER
	RTS			; RETURN TO CALLER
; 
; COME HERE TO BEGIN EXECUTION OF THE SOURCE PROGRAM
;
EXEC	JSR	LFOUT		; NEWLINE
	LDA	#>LOC		; COPY PGM START PTR MSB
	STA	LOCP+1
	LDA	#<LOC-1		; COPY START PTR LSB MINUS 1
	STA	LOCP
LOOPI	JSR	INCP		; STEP TO NEXT PGM BYTE
LOOP	LDA	(LOCP),Y	; LOAD PGM BYTE
	CMP	#'*'		; *  CHAR ?
	BLE	LOOPI		; YES (OR IGNOREABLE CONT CHAR)
;
; PROCESS Y OR N FLAG TESTS
	CMP	#'Y'		; Y  ?
	BEQ	TFLG		; YES
	CMP	#'N'		; N  ?
	BNE	XA		; BRANCH NOT A FLAG TEST
;
TFLG	JSR	INCP		; STEP LOC OVER Y OR N
	CMP	FLG		; COMPARE TO CURRENT MATCH FLAG
	BEQ	LOOP		; IT'S EQUAL SO EXECUTE THE STMT
; 	
; IT'S A FLAG FAILURE, SKIP OVER THE STMT
SKIP	JSR	INCP		; STEP LOC PTR
	LDA	(LOCP),Y	; NEXT CHAR IN PGM
	CMP	#'\r'		; AT END OF STMT ?
	BNE	SKIP		; NOT YET, SO LOOP
	BEQ	LOOPI		; AT NEXT STMT, GO DO IT
;
; PROCESS ACCEPT STATEMENT
XA	CMP	#'A'		; A  ?
	BNE	XM		; NO
	LDA	LOCP		; YES, SAVE LOC OF LAST ACCEPT
	STA	LSTP		; COPY POINTER LSB
	LDA	LOCP+1		; AND POINTER MSB
	STA	LSTP+1
	JSR	JIN		; ACCEPT ONE CHAR FROM KYBD
	STA	CHR		; SAVE IT
	JSR	INCP		; MOVE OVER A
PCR	JSR	LFOUT		; PRINT LINEFEED
	JMP	LOOPI		; STEP OVER : AND CONTINUE
;
; PROCESS MATCH STATEMENT
XM	CMP	#'M'		; M  ?
	BNE	XJ		; NO
	JSR	INCP		; STEP OVER M
	JSR	INCP		; STEP OVER :
	LDA	(LOCP),Y	; GET MATCH CHAR
	LDX	#'Y'		; ASSUME MATCH WILL BE TRUE
	CMP	CHR		; COMPARE MATCH CHAR WITH INPUT
	BEQ	MX		; EQUAL, SO STORE 'Y' FLAG
	LDX	#'N'		; RESULT IS 'N'
MX	STX	FLG		; SET MATCH FLAG TO Y OR N
	JMP	LOOPI		; STEP OVER MATCH CHAR AND CONT
;
; PROCESS JUMP STATEMENT
XJ	CMP	#'J'		; J  ?
	BNE	XS		; NO
	JSR	INCP		; STEP OVER J
	JSR	INCP		; STEP OVER :
	LDA	(LOCP),Y	; LOAD DESTINATION
	AND	#$F		; TRANSLATE FROM ASCII
	BEQ	JZ		; AND CHECK IF ZERO
	TAX			; NO, SAVE DEST# IN X REGISTER
	BNE	JF		; AND GO FIND IT
JZ	LDA	LSTP		; ZERO, SO BACK TO LAST ACCEPT
	STA	LOCP		; COPY POINTER LSB
	LDA	LSTP+1		; COPY POINTER MSB
	STA	LOCP+1
	JMP	LOOP		; AND CONTINUE FROM THERE
;
; SKIP FORWARD UNTILL PAST N '*' MARKERS (N IS IN X REGISTER)
JF	JSR	INCP		; STEP PGM LOC
	LDA	(LOCP),Y	; NEXT CHAR
	CMP	#'*'		; * MARK  ?
	BNE	JF		; NO, KEEP LOOPING
	DEX			; FOUND ONE, COUNT IT
	BNE	JF		; LOOP IF REQ'D TO FIND MORE
	JMP	LOOPI		; DESTINATION FOUND, GO EXECUTE
;
; PROCESS STOP (OR SUBROUTINE) STATEMENT
XS	CMP	#'S'		; S  ?
	BNE	XT		; NO
	JSR	INCP		; STEP OVER S
	JSR	INCP		; STEP OVER :
	LDA	(LOCP),Y	; PARAMETER TO REG A
	JSR	INCP		; STEP OVER PARAMETER
; NEXT STMT MAY BE MADE TO BE A JSR TO A USER SUBR
	JMP	SUB		; GO TO USER SUBR (OR TO EDITOR)
;	JMP	LOOP		; CONT UPON RETURN FROM USER SUBR
;
; PROCESS TYPE STATEMENT AND SYNTAX ERRORS
XT	CMP	#'T'		; T  ?
	BNE	TE		; NO, IT'S AN ERROR
	JSR	INCP		; YES, STEP OVER T
	JSR	INCP		; STEP OVER :
TE	JSR	PRT		; PRINT UP TO CR
	JSR	LFOUT		; PRINT LINE FEED
	JMP	LOOP		; DONE WITH T
;
; SUBR TO PRINT UP TO NEXT CR
PRT	LDX	#$40		; COUNT OF 64
PRTA	LDA	(LOCP),Y	; NEXT CHAR
	DEX			; DECREMENT SAFETY COUNTER
	BEQ	PRTB		; EXIT IF OVER 64 OR UNTIL CR
	JSR	JOUT		; PRINT IT
	LDA	(LOCP),Y	; RELOAD CHAR TO A
	JSR	INCP		; STEP LOC PTR
	CMP	#'\r'		; CR ?
	BNE	PRTA		; NOT CR, LOOP
PRTB	RTS			; DONE, RETURN
INCP	INC	LOCP		; INCR LOC POINTER LSB
	BNE	DONE		; DIDNT PASS PAGE BOUNDARY
	INC	LOCP+1		; INCR LOC POINTER MSB
DONE	RTS			; RETURN TO CALLER
;
; ABOVE IS END OF READ ONLY PORTION OF THE PROGRAM
;
; USER PROGRAM STARTS HERE
;
LOC	.EQU	*

	.END