; 		WADUZITDO
;	6800 VERSION BY LARRY KHERIATY
;
;	6502 VERSION BY DIMITRI THEULINGS
;
; KIM-1 SUBROUTINES USED
GETCH	.EQU	$1E5A		; INPUT FROM KEYBOARD TO A
OUTCH	.EQU	$1EA0		; OUTPUT FROM A TO TERMINAL
CRLF	.EQU	$1E2F		; OUTPUT A CR/LF TO TERMINAL

;
; ZERO PAGE DATA
;
LST	.EQU	$60		; PLACE TO SACE LOC OF LAST A:
CHR	.EQU	$61		; PLACE TO SAVE LAST INPUT CHAR
FLG	.EQU	$62		; PLACE TO SAVE MATCH FLAG
TEMP	.EQU	$63		; PLACE TO SAVE Y OR Y REGISTERS

; ENTER SYSTEM AT LOCATION 200 WITH STACK POINTER PRESET
; TO SCRATCH PAD RAM ENOUGH FOR A FEW LEVELS OF CALL
	.ORG	$200
SUB	.EQU	*		; USER SUBR START (CAN BE MODIFIED)
;
START	LDX	#0		; RESET SOURCE PROGRAM AREA PTR
EGET	JSR	JIN		; ACCEPT SOURCE CHAR
	CMP	#'\\'		; \  ?
	BEQ	START		; YES, BACK UP TO PROGRAM START
;
	CMP	#'$'		; $  ?
	BEQ	EXEC		; YES, GO EXECUTE THE PROGRAM
;
	CMP	#8		; BS  ?
	BNE	DIS		; NO
	CPX	#0		; ALREADY AT FIRST POSITION
	BEQ	EGET		; YES, LOOP BACK NOW
	DEX			; NO, BACK UP ONE IN SOURCE
	JMP	EGET		; LOOP BACK
;
; PROCESS DISPLAY OF NEXT LINE
DIS	CMP	#'/'		; /  ?
	BNE	PAD		; NO
	JSR	PRT		; GO PRINT TO CR
EPLF	JSR	LFOUT		; PRINT LINEFEED AND NULLS
	JMP	EGET		; LOOP
;
; DO LINE REPLACEMENT - PAD TO END OF STMT WITH NULLS
PAD	CMP	#'%'		; %  ?
	BNE	CHAR		; NO
	LDA	#$D		; CR
	JSR	JOUT		; PRINT IT
	LDY	#$40		; COUNT OF 64
PADL	LDA	LOC,X		; CR
	CMP	#$D		; AT CR YET?
	BEQ	CHAR		; YES QUIT PADDING
	LDA	#0		; NULL CHARACTER
	STA	LOC,X		; PAD WITH NULL
	INX			; INCR LOC PTR
	DEY			; DECREMENT SAFETY COUNTER
	BNE	PADL		; LOOP TILL CR OR 64 NULLS
;
; STORE ENTERED SOURCE CHAR IN PROGRAM
CHAR	STA	LOC,X		; CHAR TO SOURCE LOC
	INX			; MOVE LOC PTR UP ONE
	CMP	#$D		; IS IT A CR ?
	BEQ	EPLF		; YES, ECHO A LINEFEED
	JMP	EGET		; NO, GET ANOTHER CHAR
;
; NEXT FEW LINES MUST BE ALTERED IF NOT USING KIM-1
JIN	JMP	GETCH		; CALL CHARACTER INPUT ROUTINE
JOUT	STY	TEMP		; PRESERVE VALUE OF Y REG
	JSR	OUTCH		; CALL CHARACTER OUTPUT ROUTINE
	LDY	TEMP		; RESTORE Y REGISTER
	RTS			; RETURN TO CALLER
LFOUT	STX	TEMP		; PRESERVE VALUE OF X
	JSR	CRLF		; CALL CR/LF OUTPUT ROUTINE
	LDX	TEMP		; RESTORE X REGISTER
	RTS			; RETURN TO CALLER
; 
; COME HERE TO BEGIN EXECUTION OF THE SOURCE PROGRAM
;
EXEC	JSR	LFOUT		; NEWLINE
	LDX	#$FF		; RESET PROGRAM POINTER MINUS 1
LOOPI	INX			; POINT TO NEXT PGM BYTE
LOOP	LDA	LOC,X		; NEXT PGM BYTE
	CMP	#'*'		; *  CHAR ?
	BEQ	LOOPI		; YES
	BCC	LOOPI		; (OR IGNOREABLE CONT CHAR)
;
; PROCESS Y OR N FLAG TESTS
	CMP	#'Y'		; Y  ?
	BEQ	TFLG		; YES
	CMP	#'N'		; N  ?
	BNE	XA		; BRANF NOT A FLAG TEST
;
TFLG	INX			; STEP LOC OVER Y OR N
	CMP	FLG		; COMPARE TO CURRENT MATCH FLAG
	BEQ	LOOP		; IT'S EQUAL SO EXECUTE THE STMT
; 	
; IT'S A FLAG FAILURE, SKIP OVER THE STMT
SKIP	INX			; STEP LOC PTR
	LDA	LOC,X		; NEXT CHAR IN PGM
	CMP	#$D		; AT END OF STMT ?
	BNE	SKIP		; NOT YET, SO LOOP
	BEQ	LOOPI		; AT NEXT STMT, GO DO IT
;
; PROCESS ACCEPT STATEMENT
XA	CMP	#'A'		; A  ?
	BNE	XM		; NO
	STX	LST		; YES, SAVE LOC OF LAST ACCEPT
	JSR	JIN		; ACCEPT ONE CHAR FROM KYBD
	STA	CHR		; SAVE IT
	INX			; MOVE OVER A
PCR	JSR	LFOUT		; PRINT LINEFEED
	JMP	LOOPI		; STEP OVER : AND CONTINUE
;
; PROCESS MATCH STATEMENT
XM	CMP	#'M'		; M  ?
	BNE	XJ		; NO
	INX			; STEP OVER M
	INX			; STEP OVER :
	LDA	LOC,X		; GET MATCH CHAR
	LDY	#'Y'		; ASSUME MATCH WILL BE TRUE
	CMP	CHR		; COMPARE MATCH CHAR WITH INPUT
	BEQ	MX		; EQUAL, SO STORE 'Y' FLAG
	LDY	#'N'		; RESULT IS 'N'
MX	STY	FLG		; SET MATCH FLAG TO Y OR N
	JMP	LOOPI		; STEP OVER MATCH CHAR AND CONT
;
; PROCESS JUMP STATEMENT
XJ	CMP	#'J'		; J  ?
	BNE	XS		; NO
	LDA	LOC+2,X		; LOAD DESTINATION
	AND	#$F		; TRANSLATE FROM ASCII
	BEQ	JZ		; AND CHECK IF ZERO
	TAY			; NO, SAVE DEST IN Y REGISTER
	BNE	JF		; AND GO FIND IT
JZ	LDX	LST		; ZERO, SO BACK TO LAST ACCEPT
	JMP	LOOP		; AND CONTINUE FROM THERE
;
; SKIP FORWARD UNTILL PAST N '*' MARKERS (N IS IN Y REGISTER)
JF	INX			; STEP PGM LOC
	LDA	LOC,X		; NEXT CHAR
	CMP	#'*'		; * MARK  ?
	BNE	JF		; NO, KEEP LOOPING
	DEY			; FOUND ONE, COUNT IT
	BNE	JF		; LOOP IF REQ'D TO FIND MORE
	BEQ	LOOPI		; DESTINATION FOUND, GO EXECUTE
;
; PROCESS STOP (OR SUBROUTINE) STATEMENT
XS	CMP	#'S'		; S  ?
	BNE	XT		; NO
	INX			; STEP OVER S
	INX			; STEP OVER :
	LDA	LOC,X		; PARAMETER TO REG A
	INX			; STEP OVER PARAMETER
; NEXT STMT MAY BE MADE TO BE A JSR TO A USER SUBR
	JMP	SUB		; GO TO USER SUBR (OR TO EDITOR)
;	JMP	LOOP		; CONT UPON RETURN FROM USER SUBR
;
; PROCESS TYPE STATEMENT AND SYNTAX ERRORS
XT	CMP	#'T'		; T  ?
	BNE	TE		; NO, IT'S AN ERROR
	INX			; YES, STEP OVER T
	INX			; STEP OVER :
TE	JSR	PRT		; PRINT UP TO CR
	JSR	LFOUT		; PRINT LINE FEED
	JMP	LOOP		; DONE WITH T
;
; SUBR TO PRINT UP TO NEXT CR
PRT	LDY	#$40		; COUNT OF 64
PRTA	LDA	LOC,X		; NEXT CHAR
	DEY			; DECREMENT SAFETY COUNTER
	BEQ	PRTB		; EXIT IF OVER 64 OR UNTIL CR
	JSR	JOUT		; PRINT IT
	LDA	LOC,X		; RELOAD CHAR TO A
	INX			; STEP LOC PTR
	CMP	#$D		; CR ?
	BNE	PRTA		; NOT CR, LOOP
PRTB	RTS			; DONE, RETURN
;
; ABOVE IS END OF READ ONLY PORTION OF THE PROGRAM
;
; PROGRAM TEXT STARTS HERE
;
LOC	.EQU	*

	.END